<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Roman to Integer]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F16%2FRoman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解析趁此机会，我们可以来了解一下罗马数字的规则，麻麻再也不用担心我读错iPhoneX了。 罗马数字是基于七个不同的符号对应数字形成的，分别是：I, V, X, L, C, D and M。 I V X L C D M 1 5 10 50 100 500 1000 例如，2用II 罗马数字写成，只需要两个加在一起。12写为XII，也就是X+ II。数字27写为XXVII，也就是XX+ V+ II。 罗马数字通常从左到右从最大到最小。但是，数字4不是IIII。相反，4被写为IV。因为1在5之前，我们减去4。同样的原则适用于9的罗马数字IX。我们举几个栗子： I可以放在V（5）和X（10）之前表示4和9。 X可以放在L（50）和C（100）之前表示40和90。 C可以放在D（500）和M（1000）之前表示400和900。 回到这道题，我们遍历传入的字符来得到相应的值数组，一一对应罗马数字，然后循环判断前一个数是否比后一个数大，是则加，否则减。 12345678910111213141516171819202122232425262728293031323334353637383940public int romanToInt(String s) &#123; int[] number = new int[s.length()]; for(int i = 0; i &lt; s.length(); i++)&#123; switch(s.charAt(i))&#123; case 'M': number[i] = 1000; break; case 'D': number[i] = 500; break; case 'C': number[i] = 100; break; case 'L': number[i] = 50; break; case 'X': number[i] = 10; break; case 'V': number[i] = 5; break; case 'I': number[i] = 1; break; default: &#125; &#125; int sum = 0; for(int i = 0; i &lt; number.length - 1; i++)&#123; if(number[i] &lt; number[i + 1])&#123; sum -= number[i]; &#125;else&#123; sum += number[i]; &#125; &#125; return sum + number[number.length - 1];&#125; 此题的排名能达到99%以上，基本上达到了最优解。 复杂性分析 时间复杂度：O(n). 空间复杂度：O(N).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome Number]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F15%2FPalindrome-Number%2F</url>
    <content type="text"><![CDATA[题目Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 解析本题要求最好不能使用额外的内存，我们也就不能选择把整数换成字符串再进行反转判断。这道题的思路跟上一题《Reverse Integer》的解法很像，只不过这次我们只需要将整数分为左右两边，右边的进行反转，最后就能进行判断了。 1234567891011public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))&#123; return false; &#125; int reverse = 0; while(x &gt; reverse)&#123; reverse = reverse * 10 + x % 10; x /= 10; &#125; return x == reverse || x == reverse / 10;&#125; 复杂性分析 时间复杂度：O(log~10~(n)). 因为我们每次递归都会除以10，所以时间复杂度也就会是O(log~10~(n))了。 空间复杂度：O(1).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果把人生比成一局DOTA，大家现在局势如何？接下来怎么打？]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2F%E5%A6%82%E6%9E%9C%E6%8A%8A%E4%BA%BA%E7%94%9F%E6%AF%94%E6%88%90%E4%B8%80%E5%B1%80DOTA%EF%BC%8C%E5%A4%A7%E5%AE%B6%E7%8E%B0%E5%9C%A8%E5%B1%80%E5%8A%BF%E5%A6%82%E4%BD%95%EF%BC%9F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%80%8E%E4%B9%88%E6%89%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我一出生的时候，便看到了樱花纷落的大树下，一群人背对着我走出去。临走前他们却不忘回头跟我说，买个信使，还有，中路补个眼。 我揉了揉眼睛，旁边一个满脸泛金的大叔递给我一个拐杖一样的东西，我很疑惑：为什么给我这个？ 他笑了笑，问我要什么。刚想开口，远处砸来几声怒吼：快来下路保我！ 我艰难站起来，看见自己穿着平时自己最喜欢的衣服，嗯，天空一样的颜色。大叔塞给我一个眼，便把我推了出去。 之后，我只记得天空掠过了一只小鸟，地上也溜过了一只松鼠，接着便天黑了。到处都是刀光剑影，到处都是杀戮的配音，震得我耳鸣。 可是我无能为力，我撑着大叔给我的那根拐杖逃避了一次又一次战斗，回头发觉所有人都躺在血泊中，余一个杀红眼的人，不断嘲笑我。 没有人杀过我，或者说，没有人愿意去在乎这个弱小的身躯。 我很害怕，一出生便被注定杀戮，信仰？快感？ 终于在我耗尽所有力气后，我又回到了大叔身边。这时的樱花树下，已经被马蹄践踏得面目全非，平时喷涌而出的泉水也已了无生机。我再次被推了出去，这次我站在了一个很高的地方，我可以看见一个个从岩浆里面走出来的恶魔，正面目狰狞地如死神一般袭来。 结局显而易见，昔日英雄被斩落马下，家园也被尽拆。但是机会来了，奋战到最后一刻的大哥把所有恶魔都困在了同一个地方。 “快放大！” 这是我听见第一次有人对我抱有希望的呐喊。手中的拐杖亮了起来，天空开始风云变幻，地上的樱花也被扬起，此时所有的恶魔似乎都想努力逃窜。 我在干什么？为什么他们这么怕我？ 难道这样能赢？ 哦， 我记起来了，我叫冰晶室女，我正在召唤一场暴风雪，这样一来，所有的恶魔都将退散。 但是我哭了，暴风雪逐渐消失，世界树在这个时候轰然倒塌，最后记得的时候，我趴在地上哭。 因为我听见一个小恶魔对我说，小姐姐好厉害，我这一生都没看过雪呢。 嗯，我这一生，还没见到你呢。]]></content>
      <categories>
        <category>我说故事你说好的</category>
      </categories>
      <tags>
        <tag>故事君</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Integer]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2FReverse-Integer%2F</url>
    <content type="text"><![CDATA[题目Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 解析本题主要是取余的应用，通过递归反转整数，到最后取到我们需要的反转值。但是，我们需要考虑到 int 的范围，以防溢出（ -2147483648～2147483647 ）。 1234567891011public int reverse(int x) &#123; int res = 0; while(x != 0) &#123; int single = x % 10; x /= 10; if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; single &gt; 7)) return 0; if (res &lt; Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; single &lt; -8)) return 0; res = res * 10 + single; &#125; return res;&#125; 我们首先选择的方法会决定最后得出的结果，如果一开始就想到用递归，那么解出这道题便不会太难，但本题的也只排在35%，以后尽量寻求合理范围的最优解。 复杂性分析 时间复杂度：O(log~10~(n)). 因为我们每次递归都会除以10，所以时间复杂度也就会是O(log~10~(n))了。 空间复杂度：O(1).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2FTwo-Sum%2F</url>
    <content type="text"><![CDATA[题目Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解析哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。 Java 中的 HashSet 用来存储一个集合，可以通过查找元素判断是否在集合中。举个例子，如果我们只需要判断的元素有限，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。 Java 中的 HashMap 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。 对于这道题而言，如果我们采用普通的遍历判断，比如： 12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 那么时间间复杂度将会达到O(n^2^)，而空间复杂度为O(1)。不过，我们心里会想，怎么会这么简单呢？如果想更进一步找到更好的解法，可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。 用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。 1234567891011public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; indexForNum = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (indexForNum.containsKey(target - nums[i])) &#123; return new int[]&#123;indexForNum.get(target - nums[i]), i&#125;; &#125; else &#123; indexForNum.put(nums[i], i); &#125; &#125; return null;&#125; 此题AC并不难，但是最后这种解法也只是超过66%左右，但是这已经足够我们学习哈希表了。 复杂性分析 时间复杂度：O(N)。 空间复杂度：O(N)。]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[开通此博客之初，是为了更好地记录自己生活的点滴，我们活得如此有趣，总会有一些话想对你说。一开始我会记录自己在LeetCode上的学习经历，之后会发生什么，我也不知道。]]></content>
  </entry>
</search>
