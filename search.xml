<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如果把人生比成一局DOTA，大家现在局势如何？接下来怎么打？]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2F%E5%A6%82%E6%9E%9C%E6%8A%8A%E4%BA%BA%E7%94%9F%E6%AF%94%E6%88%90%E4%B8%80%E5%B1%80DOTA%EF%BC%8C%E5%A4%A7%E5%AE%B6%E7%8E%B0%E5%9C%A8%E5%B1%80%E5%8A%BF%E5%A6%82%E4%BD%95%EF%BC%9F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%80%8E%E4%B9%88%E6%89%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我一出生的时候，便看到了樱花纷落的大树下，一群人背对着我走出去。临走前他们却不忘回头跟我说，买个信使，还有，中路补个眼。 我揉了揉眼睛，旁边一个满脸泛金的大叔递给我一个拐杖一样的东西，我很疑惑：为什么给我这个？ 他笑了笑，问我要什么。刚想开口，远处砸来几声怒吼：快来下路保我！ 我艰难站起来，看见自己穿着平时自己最喜欢的衣服，嗯，天空一样的颜色。大叔塞给我一个眼，便把我推了出去。 之后，我只记得天空掠过了一只小鸟，地上也溜过了一只松鼠，接着便天黑了。到处都是刀光剑影，到处都是杀戮的配音，震得我耳鸣。 可是我无能为力，我撑着大叔给我的那根拐杖逃避了一次又一次战斗，回头发觉所有人都躺在血泊中，余一个杀红眼的人，不断嘲笑我。 没有人杀过我，或者说，没有人愿意去在乎这个弱小的身躯。 我很害怕，一出生便被注定杀戮，信仰？快感？ 终于在我耗尽所有力气后，我又回到了大叔身边。这时的樱花树下，已经被马蹄践踏得面目全非，平时喷涌而出的泉水也已了无生机。我再次被推了出去，这次我站在了一个很高的地方，我可以看见一个个从岩浆里面走出来的恶魔，正面目狰狞地如死神一般袭来。 结局显而易见，昔日英雄被斩落马下，家园也被尽拆。但是机会来了，奋战到最后一刻的大哥把所有恶魔都困在了同一个地方。 “快放大！” 这是我听见第一次有人对我抱有希望的呐喊。手中的拐杖亮了起来，天空开始风云变幻，地上的樱花也被扬起，此时所有的恶魔似乎都想努力逃窜。 我在干什么？为什么他们这么怕我？ 难道这样能赢？ 哦， 我记起来了，我叫冰晶室女，我正在召唤一场暴风雪，这样一来，所有的恶魔都将退散。 但是我哭了，暴风雪逐渐消失，世界树在这个时候轰然倒塌，最后记得的时候，我趴在地上哭。 因为我听见一个小恶魔对我说，小姐姐好厉害，我这一生都没看过雪呢。 嗯，我这一生，还没见到你呢。]]></content>
      <categories>
        <category>我说故事你说好的</category>
      </categories>
      <tags>
        <tag>故事君</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Integer]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2FReverse-Integer%2F</url>
    <content type="text"><![CDATA[题目Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 解析本题主要是取余的应用，通过递归反转整数，到最后取到我们需要的反转值。但是，我们需要考虑到 int 的范围，以防溢出（ -2147483648～2147483647 ）。 1234567891011public int reverse(int x) &#123; int res = 0; while(x != 0) &#123; int single = x % 10; x /= 10; if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; single &gt; 7)) return 0; if (res &lt; Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; single &lt; -8)) return 0; res = res * 10 + single; &#125; return res;&#125; 我们首先选择的方法会决定最后得出的结果，如果一开始就想到用递归，那么解出这道题便不会太难，但本题的也只排在35%，以后尽量寻求合理范围的最优解。]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2FTwo-Sum%2F</url>
    <content type="text"><![CDATA[题目Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解析哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。 Java 中的 HashSet 用来存储一个集合，可以通过查找元素判断是否在集合中。举个例子，如果我们只需要判断的元素有限，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。 Java 中的 HashMap 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。 对于这道题而言，如果我们采用普通的遍历判断，比如： 12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 那么时间间复杂度将会达到O(n^2^)，而空间复杂度为O(1)。不过，我们心里会想，怎么会这么简单呢？如果想更进一步找到更好的解法，可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。 ​用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。 1234567891011public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; indexForNum = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (indexForNum.containsKey(target - nums[i])) &#123; return new int[]&#123;indexForNum.get(target - nums[i]), i&#125;; &#125; else &#123; indexForNum.put(nums[i], i); &#125; &#125; return null;&#125; 此题AC并不难，但是最后这种解法也只是超过66%左右，但是这已经足够我们学习哈希表了。]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[开通此博客之初，是为了更好地记录自己生活的点滴，我们活得如此有趣，总会有一些话想对你说。一开始我会记录自己在LeetCode上的学习经历，之后会发生什么，我也不知道。]]></content>
  </entry>
</search>
