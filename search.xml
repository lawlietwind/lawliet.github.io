<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Longest Common Prefix]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F17%2FLongest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[题目Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1: 12Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot; Example 2: 123Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings. 解析本题也是关于分解字符串的问题，题目给出的输入都会是小写，所以我们不需要考虑大小写这个问题。主要是先判断字符为空的情况，然后让后一位与前一位比较，有相同的字符就取出来，然后继续与后一位判断，最后返回递归的值。 123456789101112131415161718public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) &#123; return ""; &#125; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) &#123; return ""; &#125; &#125; return prefix;&#125; 这种写法属于水平扫描，也就是说我们从第一位取到最后一位，一个个进行比较截断。 还有一种垂直扫描，我们假设一个非常短的字符串位于数组的末尾。我们在移动到下一列之前，在同一列（字符串的相同字符索引）上从上到下比较字符。 1234567891011public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return ""; for (int i = 0; i &lt; strs[0].length() ; i++)&#123; char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); &#125; &#125; return strs[0];&#125; 此题的排名一样达到了99%以上，基本上达到了最优解。 复杂性分析 时间复杂度：O(S). S 是所有字符串长度的总和，在最坏的情况下，所有的 n 个字符都是一样的长度 n ，我们把 S~1~ 和 [S~2~…S~n~] 进行了比较，总共有 S 个字符进行了比较， S 就是输入数组中所有字符串长度的总和。 空间复杂度：O(1). 我们并没有使用额外的空间。]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零度的温暖]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F16%2F%E9%9B%B6%E5%BA%A6%E7%9A%84%E6%B8%A9%E6%9A%96%2F</url>
    <content type="text"><![CDATA[小刺猬很寂寞，虽然她有一大群朋友。 其实，平时大家很喜欢她，很善良很热心，可是刺猬身上有着一层厚厚的刺，使得周围人和她在一起时总是要小心翼翼避免受到伤害。 冬季渐渐来临，空气变得很冷，小刺猬贪恋和大家在一起的感觉，每天玩得很晚，不想回家，也忘了妈妈说过的关于冬眠的话。 有一天，天空忽然下了大雪，大雪覆盖了回家的路，小刺猬回不了家了。她害怕的躲在大树后面。看着渐渐降临的夜幕，开始胡思乱想。 这时候一个雪人问她，你迷路了吗？小刺猬说，我很害怕，很困。雪人说，那你在我怀里睡一觉吧。 她问，你不怕我伤害你吗 他说，没关系，我是雪人，冰雪做的心，不懂得疼痛。 小刺猬看了看周围的漆黑，就像一只野兽张着大嘴，更加害怕。 于是她扑进了雪人怀里。 雪人的身体里始终保持着零度，零度并不是很低的温度，因为外面的温度已经降到零下十几度了。 小刺猬带着困意问雪人，呵呵你是第一个不怕被我伤害的朋友，真的很开心，但是我好困啊，我要睡觉了。明天……明天你能陪我玩吗 雪人淡定地骗她说，当然了。睡吧小家伙。我们明天见。 嗯，明天见！ 嗯，明天见。 大雪封住了整个森林，漫长的冬季里，冰天雪地，北风呼啸。 而小刺猬在雪人的怀里睡得很甜美。 她梦见第二天早上，她和雪人一起看日出。 第二年，万物复苏的美好春天终于回来了。 小刺猬在一阵悦耳的鸟叫声中迷迷糊糊的睁开了双眼，她发现雪人的帽子正盖在自己的身上。 而雪人，早已经离开了。 雪人的心，是冰雪做的。冰雪的心，不是不懂得疼痛，而是不在乎疼痛，因为你，比疼痛更重要。 我不能给你更多的温暖，但是我可以驱散寒冷。 回到那个离别的早晨。 春天是在前一天的夜晚悄悄来临的。于是在第一天的早上，温暖的阳光打在了雪人的脸上，雪人开始变小，满脸的水痕。 他无奈的看着怀里的小刺猬。 笨蛋，我骗了你啊。 如果你说，我对你的好，是我给你的，微不足道的，零度的温暖。 那我也要感谢你，给了我一颗，懂得了疼痛的心。]]></content>
      <categories>
        <category>我说故事你说好的</category>
      </categories>
      <tags>
        <tag>故事君</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Roman to Integer]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F16%2FRoman-to-Integer%2F</url>
    <content type="text"><![CDATA[题目Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: &quot;III&quot;Output: 3 Example 2: 12Input: &quot;IV&quot;Output: 4 Example 3: 12Input: &quot;IX&quot;Output: 9 Example 4: 123Input: &quot;LVIII&quot;Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3. Example 5: 123Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 解析趁此机会，我们可以来了解一下罗马数字的规则，麻麻再也不用担心我读错iPhoneX了。 罗马数字是基于七个不同的符号对应数字形成的，分别是：I, V, X, L, C, D and M。 I V X L C D M 1 5 10 50 100 500 1000 例如，2用II 罗马数字写成，只需要两个加在一起。12写为XII，也就是X+ II。数字27写为XXVII，也就是XX+ V+ II。 罗马数字通常从左到右从最大到最小。但是，数字4不是IIII。相反，4被写为IV。因为1在5之前，我们减去4。同样的原则适用于9的罗马数字IX。我们举几个栗子： I可以放在V（5）和X（10）之前表示4和9。 X可以放在L（50）和C（100）之前表示40和90。 C可以放在D（500）和M（1000）之前表示400和900。 回到这道题，我们遍历传入的字符来得到相应的值数组，一一对应罗马数字，然后循环判断前一个数是否比后一个数大，是则加，否则减。 123456789101112131415161718192021222324252627282930313233343536373839 public int romanToInt(String s) &#123; int[] number = new int[s.length()]; for(int i = 0; i &lt; s.length(); i++)&#123; switch(s.charAt(i))&#123; case 'M': number[i] = 1000; break; case 'D': number[i] = 500; break; case 'C': number[i] = 100; break; case 'L': number[i] = 50; break; case 'X': number[i] = 10; break; case 'V': number[i] = 5; break; case 'I': number[i] = 1; break; default: &#125; &#125; int sum = 0; for(int i = 0; i &lt; number.length - 1; i++)&#123; if(number[i] &lt; number[i + 1])&#123; sum -= number[i]; &#125;else&#123; sum += number[i]; &#125; &#125; return sum + number[number.length - 1];&#125; 此题的排名能达到99%以上，基本上达到了最优解。 复杂性分析 时间复杂度：O(N). 空间复杂度：O(N).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Palindrome Number]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F15%2FPalindrome-Number%2F</url>
    <content type="text"><![CDATA[题目Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: 12Input: 121Output: true Example 2: 123Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: 123Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 解析本题要求最好不能使用额外的内存，我们也就不能选择把整数换成字符串再进行反转判断。这道题的思路跟上一题《Reverse Integer》的解法很像，只不过这次我们只需要将整数分为左右两边，右边的进行反转，最后就能进行判断了。 1234567891011public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0))&#123; return false; &#125; int reverse = 0; while(x &gt; reverse)&#123; reverse = reverse * 10 + x % 10; x /= 10; &#125; return x == reverse || x == reverse / 10;&#125; 复杂性分析 时间复杂度：O(log~10~(n)). 因为我们每次递归都会除以10，所以时间复杂度也就会是O(log~10~(n))了。 空间复杂度：O(1).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如果把人生比成一局DOTA，大家现在局势如何？接下来怎么打？]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2F%E5%A6%82%E6%9E%9C%E6%8A%8A%E4%BA%BA%E7%94%9F%E6%AF%94%E6%88%90%E4%B8%80%E5%B1%80DOTA%EF%BC%8C%E5%A4%A7%E5%AE%B6%E7%8E%B0%E5%9C%A8%E5%B1%80%E5%8A%BF%E5%A6%82%E4%BD%95%EF%BC%9F%E6%8E%A5%E4%B8%8B%E6%9D%A5%E6%80%8E%E4%B9%88%E6%89%93%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我一出生的时候，便看到了樱花纷落的大树下，一群人背对着我走出去。临走前他们却不忘回头跟我说，买个信使，还有，中路补个眼。 我揉了揉眼睛，旁边一个满脸泛金的大叔递给我一个拐杖一样的东西，我很疑惑：为什么给我这个？ 他笑了笑，问我要什么。刚想开口，远处砸来几声怒吼：快来下路保我！ 我艰难站起来，看见自己穿着平时自己最喜欢的衣服，嗯，天空一样的颜色。大叔塞给我一个眼，便把我推了出去。 之后，我只记得天空掠过了一只小鸟，地上也溜过了一只松鼠，接着便天黑了。到处都是刀光剑影，到处都是杀戮的配音，震得我耳鸣。 可是我无能为力，我撑着大叔给我的那根拐杖逃避了一次又一次战斗，回头发觉所有人都躺在血泊中，余一个杀红眼的人，不断嘲笑我。 没有人杀过我，或者说，没有人愿意去在乎这个弱小的身躯。 我很害怕，一出生便被注定杀戮，信仰？快感？ 终于在我耗尽所有力气后，我又回到了大叔身边。这时的樱花树下，已经被马蹄践踏得面目全非，平时喷涌而出的泉水也已了无生机。我再次被推了出去，这次我站在了一个很高的地方，我可以看见一个个从岩浆里面走出来的恶魔，正面目狰狞地如死神一般袭来。 结局显而易见，昔日英雄被斩落马下，家园也被尽拆。但是机会来了，奋战到最后一刻的大哥把所有恶魔都困在了同一个地方。 “快放大！” 这是我听见第一次有人对我抱有希望的呐喊。手中的拐杖亮了起来，天空开始风云变幻，地上的樱花也被扬起，此时所有的恶魔似乎都想努力逃窜。 我在干什么？为什么他们这么怕我？ 难道这样能赢？ 哦， 我记起来了，我叫冰晶室女，我正在召唤一场暴风雪，这样一来，所有的恶魔都将退散。 但是我哭了，暴风雪逐渐消失，世界树在这个时候轰然倒塌，最后记得的时候，我趴在地上哭。 因为我听见一个小恶魔对我说，小姐姐好厉害，我这一生都没看过雪呢。 嗯，我这一生，还没见到你呢。]]></content>
      <categories>
        <category>我说故事你说好的</category>
      </categories>
      <tags>
        <tag>故事君</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reverse Integer]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F14%2FReverse-Integer%2F</url>
    <content type="text"><![CDATA[题目Given a 32-bit signed integer, reverse digits of an integer. Example 1: 12Input: 123Output: 321 Example 2: 12Input: -123Output: -321 Example 3: 12Input: 120Output: 21 解析本题主要是取余的应用，通过递归反转整数，到最后取到我们需要的反转值。但是，我们需要考虑到 int 的范围，以防溢出（ -2147483648～2147483647 ）。 1234567891011public int reverse(int x) &#123; int res = 0; while(x != 0) &#123; int single = x % 10; x /= 10; if (res &gt; Integer.MAX_VALUE/10 || (res == Integer.MAX_VALUE / 10 &amp;&amp; single &gt; 7)) return 0; if (res &lt; Integer.MIN_VALUE/10 || (res == Integer.MIN_VALUE / 10 &amp;&amp; single &lt; -8)) return 0; res = res * 10 + single; &#125; return res;&#125; 我们首先选择的方法会决定最后得出的结果，如果一开始就想到用递归，那么解出这道题便不会太难，但本题的也只排在35%，以后尽量寻求合理范围的最优解。 复杂性分析 时间复杂度：O(log~10~(n)). 因为我们每次递归都会除以10，所以时间复杂度也就会是O(log~10~(n))了。 空间复杂度：O(1).]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Two Sum]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2FTwo-Sum%2F</url>
    <content type="text"><![CDATA[题目Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解析哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。 Java 中的 HashSet 用来存储一个集合，可以通过查找元素判断是否在集合中。举个例子，如果我们只需要判断的元素有限，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。 Java 中的 HashMap 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。 对于这道题而言，如果我们采用普通的遍历判断，比如： 12345678910public int[] twoSum(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] == target - nums[i]) &#123; return new int[] &#123; i, j &#125;; &#125; &#125; &#125; throw new IllegalArgumentException("No two sum solution");&#125; 那么时间间复杂度将会达到O(n^2^)，而空间复杂度为O(1)。不过，我们心里会想，怎么会这么简单呢？如果想更进一步找到更好的解法，可以先对数组进行排序，然后使用双指针方法或者二分查找方法。这样做的时间复杂度为 O(NlogN)，空间复杂度为 O(1)。 用 HashMap 存储数组元素和索引的映射，在访问到 nums[i] 时，判断 HashMap 中是否存在 target - nums[i]，如果存在说明 target - nums[i] 所在的索引和 i 就是要找的两个数。该方法的时间复杂度为 O(N)，空间复杂度为 O(N)，使用空间来换取时间。 1234567891011public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; indexForNum = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if (indexForNum.containsKey(target - nums[i])) &#123; return new int[]&#123;indexForNum.get(target - nums[i]), i&#125;; &#125; else &#123; indexForNum.put(nums[i], i); &#125; &#125; return null;&#125; 此题AC并不难，但是最后这种解法也只是超过66%左右，但是这已经足够我们学习哈希表了。 复杂性分析 时间复杂度：O(N)。 空间复杂度：O(N)。]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Easy</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Flawliet.github.io%2F2018%2F08%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[开通此博客之初，是为了更好地记录自己生活的点滴，我们活得如此有趣，总会有一些话想对你说。一开始我会记录自己在LeetCode上的学习经历，之后会发生什么，我也不知道。]]></content>
  </entry>
</search>
